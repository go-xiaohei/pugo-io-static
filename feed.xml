<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"><channel><title>Pugo.Static - site generator</title><link>http://localhost</link><description>pugo is a simple static site generator</description><lastBuildDate>Mon, 07 Dec 2015 14:43:20 +0800</lastBuildDate><item><title>Welcome</title><link>http://localhost/2015/11/28/welcome.html</link><pubDate>Sat, 28 Nov 2015 00:00:00 +0000</pubDate><category>pugo</category><category>welcome</category><description><![CDATA[ <p>When you read the blog, <code>pugo</code> is running successfully. Then enjoy your blog journey.</p>

<p>This blog is generated from file <code>source/welcome.md</code>. You can learn it and try to write your own blog article with following guide together.</p>

<h4>blog meta</h4>

<p>Blog&rsquo;s meta data, such as title, author, are created by first <code>ini</code> section with block <strong>```ini &hellip;.. ```</strong>:</p>
<pre><code class="language-ini">; post title, required
title = Welcome to Pugo.Static

; post slug, use to build permalink and url, required
slug = welcome-pugo-static

; post created time, support
; 2015-11-28, 2015-11-28 12:28, 2015-11-28 12:28:38
date = 2015-11-28 11:28

; post updated time, optional
; if null, use created time
update_date = 2015-11-28 12:28

; author identifier, reference to meta.md [author.pugo], required
author = pugo-robot

; tags, optional
tags = pugo,welcome
</code></pre>

<h4>blog content</h4>

<p>Content are from the second section as <code>markdown</code> format:</p>
<pre><code class="language-markdown">When you read the blog, `pugo` is running successfully. Then enjoy your blog journey.

This blog is generated from file `source/welcome.md`. You can learn it and try to write your own blog article with following guide together.

...... (markdown content)
</code></pre>

<p>Just write content after blog meta, all words will be parsed as markdown content.</p>
 ]]></description></item><item><title>阅读 valyala/fasthttp —— 比官方库更快的 HTTP 包</title><link>http://localhost/2015/11/25/deep-in-fasthttp-package.html</link><pubDate>Wed, 25 Nov 2015 10:58:59 +0000</pubDate><category>Go</category><category>Http</category><description><![CDATA[ <p><a href="https://github.com/valyala/fasthttp">valyala/fasthttp</a> 是号称比官方<code>net/http</code>库更快的 http server 库。就去顺便研究了，发现一些细节的不同。</p>

<h3>处理 net.Conn 的 goroutine</h3>

<p><strong>处理net.Conn的goroutine的使用方式</strong>，和标准库有很大差别。在标准库，<code>net.Listener.Accept()</code> 到一个连接，就会开启一个goroutine：</p>
<pre><code class="language-go">// Serve accepts incoming connections on the Listener l, creating a
// new service goroutine for each.  The service goroutines read requests and
// then call srv.Handler to reply to them.
func (srv *Server) Serve(l net.Listener) error {
    defer l.Close()
    var tempDelay time.Duration // how long to sleep on accept failure
    for {
        rw, e := l.Accept()
        if e != nil {
            ......
        }
        ......
        c, err := srv.newConn(rw)
        if err != nil {
            continue
        }
        c.setState(c.rwc, StateNew) // before Serve can return
        go c.serve() // 在这里创建一个goroutine处理net.Conn的实际逻辑
    }
}
</code></pre>

<p>但是在<code>valyala/fasthttp</code>中使用的是worker的形式，开启固定数量的goroutine处理<code>net.Conn</code>。</p>

<!--more-->

<p><a href="https://github.com/valyala/fasthttp/blob/52c04f13b2bbb0a9c361825ee9b1c7306f5f0910/server.go#L582">server.go#L582</a>:</p>
<pre><code class="language-go">func (s *Server) Serve(ln net.Listener) error {
    var lastOverflowErrorTime time.Time
    var lastPerIPErrorTime time.Time
    var c net.Conn
    var err error

    maxWorkersCount := s.getConcurrency() // 获取worker的并发数
    // 创建一个worker池
    wp := &amp;workerPool{
        WorkerFunc:      s.serveConn, // 每个net.Conn的处理逻辑
        MaxWorkersCount: maxWorkersCount,
        Logger:          s.logger(),
    }
    // 开启worker内池中处理chan的清理，处理掉没有在处理请求的chan
    wp.Start()

    for {
        // 从listener收到net.Conn
        // 这个里面做的IP连接数量控制，超过会返回错误
        if c, err = acceptConn(s, ln, &amp;lastPerIPErrorTime); err != nil {
            wp.Stop()
            if err == io.EOF {
                return nil
            }
            return err
        }
        // 让worker池去处理net.Conn
        if !wp.Serve(c) {
            c.Close()
            if time.Since(lastOverflowErrorTime) &gt; time.Minute {
                s.logger().Printf(&quot;The incoming connection cannot be served, because %d concurrent connections are served. &quot;+
                    &quot;Try increasing Server.Concurrency&quot;, maxWorkersCount)
                lastOverflowErrorTime = time.Now()
            }
        }
        c = nil
    }
}
</code></pre>

<p>下一步就是 <code>wp.Serve(c)</code>，在 <a href="https://github.com/valyala/fasthttp/blob/52c04f13b2bbb0a9c361825ee9b1c7306f5f0910/workerpool.go#L92">workerpool.go#L92</a>:</p>
<pre><code class="language-go">func (wp *workerPool) Serve(c net.Conn) bool {
    ch := wp.getCh() // 从worker里获取一个workChan
    if ch == nil {
        return false
        // 如果获取不到workChan，返回false
        // 上面的代码提示错误，超过并发量了
    }
    ch.ch &lt;- c
    return true // 把net.Conn扔进workChan的chan中
}
</code></pre>

<p>之后来看怎么获取一个<code>workChan</code>，在<a href="https://github.com/valyala/fasthttp/blob/52c04f13b2bbb0a9c361825ee9b1c7306f5f0910/workerpool.go#L101">workerpool.go#L101</a>:</p>
<pre><code class="language-go">func (wp *workerPool) getCh() *workerChan {
    var ch *workerChan
    createWorker := false

    wp.lock.Lock()
    chans := wp.ready
    n := len(chans) - 1
    // 尝试获取wp.ready中空闲的workChan
    if n &lt; 0 {
        // 没有空闲的workChan，需要新建
        if wp.workersCount &lt; wp.MaxWorkersCount {
            createWorker = true
            wp.workersCount++
        }
    } else {
        // 从wp.ready空闲的workChan中取出最后一个
        ch = chans[n]
        wp.ready = chans[:n]
    }
    wp.lock.Unlock()

    if ch == nil {
        if !createWorker {
            return nil
        }
        // 从公共池中取出一个workChan来用
        vch := workerChanPool.Get()
        if vch == nil {
            // 公共池里都没有，创建一个新的
            vch = &amp;workerChan{
                ch: make(chan net.Conn, 1),
            }
        }
        ch = vch.(*workerChan)
        // 在一个goroutine里处理workChan
        go func() {
            // 开始读取操作这个workChan
            wp.workerFunc(ch)
            // workChan用完了放回公共池
            workerChanPool.Put(vch)
        }()
    }
    return ch
}
</code></pre>

<p>上面看到<code>ch.ch &lt;- c</code>，将<code>net.Conn</code>扔进了workChan的chan中。chan的处理逻辑在<code>wp.workerFunc(ch)</code>，在<a href="https://github.com/valyala/fasthttp/blob/52c04f13b2bbb0a9c361825ee9b1c7306f5f0910/workerpool.go#L152">workerpool.go#L152</a>：</p>
<pre><code class="language-go">func (wp *workerPool) workerFunc(ch *workerChan) {
    var c net.Conn
    var err error
    ......
    for c = range ch.ch {
        if c == nil { // 这里注意，传入nil就跳出循环，不处理这个workChan
            break
        }
        // 调用WorkerFunc处理每个net.Conn
        // 这个WorkerFunc在上文代码有，
        // WorkerFunc:s.serveConn
        if err = wp.WorkerFunc(c); err != nil &amp;&amp; err != errHijacked {
            errStr := err.Error()
            if !strings.Contains(errStr, &quot;broken pipe&quot;) &amp;&amp; !strings.Contains(errStr, &quot;reset by peer&quot;) {
                wp.Logger.Printf(&quot;error when serving connection %q&lt;-&gt;%q: %s&quot;, c.LocalAddr(), c.RemoteAddr(), err)
            }
        }
        if err != errHijacked {
            c.Close()
        }
        c = nil

        // 记得用完了放到wp.ready切片中
        // 以便重复使用
        if !wp.release(ch) {
            break
        }
    }
}
</code></pre>

<p>看到这里就可以总结一下。<code>valyala/fasthttp</code>其实是把<code>net.Conn</code>分配到一定数量的goroutine中执行，而不是一对一。换句话说，当goroutine数量巨大的时候，上下文切换成本开始有明显的性能影响。标准库在并发量很大的时候面临这个问题。<code>valyala/fasthttp</code>就使用了worker规避这个问题。goroutine本身就是轻量级的协程，可以即开即用。worker尽量重用每个goroutine，从而可以控制住goroutine的数量（默认的最大chan数量为256×1024）。而且如果http请求阻塞，会霸占<code>workChan</code>，直到把worker里的<code>workChan</code>耗尽（有keepAlive超时配置来处理这个问题）。</p>

<p>另外一个发现是<code>*RequestCtx</code>上下文的池。</p>

<h3>*RequestCtx 的池</h3>

<p>标准库里对于类似的http请求上下文用的是<code>*http.response</code>这个对象，问题是每次都是新的。</p>
<pre><code class="language-go">// Serve a new connection.
func (c *conn) serve() {
    ......

    for {
        // 这里返回的是*http.response
        w, err := c.readRequest()
        if c.lr.N != c.server.initialLimitedReaderSize() {
            // If we read any bytes off the wire, we're active.
            c.setState(c.rwc, StateActive)
        }
        ......

        // 要求实现的 http.Handler 接口
        // 在这里被使用
        serverHandler{c.server}.ServeHTTP(w, w.req)

        ......
    }
}
</code></pre>

<p><code>valyala/fasthttp</code>类似的结构<code>*RequestCtx</code>用的是池，<a href="https://github.com/valyala/fasthttp/blob/52c04f13b2bbb0a9c361825ee9b1c7306f5f0910/server.go#L743">server.go#L743</a>有：</p>
<pre><code class="language-go">ctx := s.acquireCtx(c)

// 其实就是:
func (s *Server) acquireCtx(c net.Conn) *RequestCtx {
    v := s.ctxPool.Get()
    var ctx *RequestCtx
    if v == nil {
        ctx = &amp;RequestCtx{
            s: s,
        }
        ctx.v = ctx
        v = ctx
    } else {
        ctx = v.(*RequestCtx)
    }
    ctx.initID()
    ctx.c = c
    return ctx
}
</code></pre>

<p><code>*RequestCtx.Request</code>和<code>*RequestCtx.Response</code>支持reset，使更安全的使用，比如 <a href="https://github.com/valyala/fasthttp/blob/52c04f13b2bbb0a9c361825ee9b1c7306f5f0910/server.go#L776">server.go#L776</a>有：</p>
<pre><code class="language-go">err = ctx.Request.Read(br)

// 就是
func (req *Request) Read(r *bufio.Reader) error {
    req.clearSkipHeader()
    err := req.Header.Read(r)
    if err != nil {
        return err
    }

    if req.Header.IsPost() {
        req.body, err = readBody(r, req.Header.ContentLength(), req.body)
        if err != nil {
            req.Reset()
            // 出错了要reset，用完了的时候同时也要
            // 在L1030，releaseReader 方法
            // 其实就是把r这个 *bufio.Reader 直接 Reset 再放回公共池
            // 下次用的时候有一个 *bufio.Reader
            return err
        }
        req.Header.SetContentLength(len(req.body))
    }
    return nil
}
</code></pre>

<p>总的来说，用池来来减少对象数量，也是增强性能最常见的方法。标准库和 <code>valyala/fasthttp</code> 都对 <code>*bufio.Reader</code> 和 <code>*bufio.Writer</code> 做了池的处理。不过对于频繁存取的服务，池的效率提升比较有限。而且<code>sync.Pool</code>没有容量控制，有时会变得不可控，需要注意一下。</p>

<h5>Thanks</h5>

<p>上文是在 <strong>Go实践群(386056972)</strong> 和群友讨论时顺便深入阅读的结果。感谢群友 <a href="http://blog.rootk.com/">华子</a> 的支持。</p>
 ]]></description></item></channel></rss>